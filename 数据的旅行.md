# 数据的旅行

## 引言
结合 Cisco Packet Tracer 搭建的实验拓扑图，分析数据在 OSI 七层模型中的封装、解封装以及路由的全过程。

## 具体流程
在 PC1 开始封装来自应用层的数据之前，PC1 首先要判断和目标主机 PC2 是否属于同一个网段，利用 IP 地址和子网掩码进行与运算，得到的网段是 192.168.1.0。然后再将自己的网段和 PC2 的 IP 地址所属网段作与运算，如果发现此 IP 地址不属于本地网段，则将数据发往本地网关处理，也就是路由器 R1 Gig0/1 接口。
![topology](https://raw.githubusercontent.com/orionleo/Markdown-Photos/master/topology.png)
   
PC1 在系统 ARP 缓存中查找路由器 R1 Gig0/1 接口的 MAC 地址。如果查找到对应的条目，则在后续用其封装成数据段。否则就向处于同一个广播域内的其他主机发送一个称为 ARP 请求的链路层广播帧。如果某台主机使用了 ARP 请求中指定的 IP 地址，它就需要向发送方响应一个 ARP 回复，其中包含了与请求相匹配的 IP 地址和对应的 MAC 地址。
![ARP](https://raw.githubusercontent.com/orionleo/Markdown-Photos/master/PC1%20ARP.png)

PC1 将数据传递至传输层进行分段处理，由于 Telnet 采用的是 TCP 协议，因此 PC1 需要使用一个端口号大于 1024 的本地端口作为源端口（假设源端口为 2333），目的端口为 23。传输层封装好后，TCP 数据段被传递至网络层，网络层在数据段的基础上添加 IP 首部，其中目的 IP 地址为 172.16.2.1，源 IP 地址为 192.168.1.1。网络层封装好后，IP 数据包被传递至数据链路层添加 Ethernet 首部，其中目的 MAC 地址为路由器 R1 Gig0/1 接口的 MAC 地址，源 MAC 地址为本机的 MAC 地址。最后在 FCS 中添加 CRC 校验和，封装完成的 Ethernet 数据帧如下图：
![PC1 -> R1](https://raw.githubusercontent.com/orionleo/Markdown-Photos/master/PC1%20-%20R1.png)

> 为什么目的 MAC 地址不是 PC2 的 MAC 地址，而是路由器 R1 Gig0/1 接口的呢？<br>
在繁杂的网络世界中充斥个各式各样的网络设备，IP 地址作为一个逻辑地址仅能负责数据包在路由器之间的转发，无法精确定位到任何一台设备。而在网络中 MAC 地址能够唯一标识一台设备或主机，可以用于局域网内寻址。<br>
换个通俗的说法，假如在北京上班的男朋友想给身处上海的女朋友送个熊本熊作为生日礼物，那么熊本熊会先经历一次地址转换从北京私网 IP 地址转换成中国公网 IP 地址，然后坐着中国公网 IP 这趟高铁从北京站出发（北京路由器），经由河北站、山东站和江苏站，最后到达上海站。到站后会再经历一次地址转换从中国公网 IP 地址转换成上海私网 IP 地址，到此 IP 地址的任务算是基本完成了，但是熊本熊还是没到女朋友的手里呀，这时就到 MAC 地址发挥的时候了，上海站的工作人员会根据女朋友的私网 IP 地址找到她所处的区（徐汇交换机）并从特定的出站口将熊本熊发往给徐汇区。熊本熊一路坐着小电驴达到徐汇区后，徐汇区的工作人员根据女朋友的之前留下的人口登记记录最后将熊本熊平安地送到了她手里。<br>
正是因为 MAC 地址只能用于局域网内寻址，发往其他网段的数据都要先经过本地网关。假设以太网首部内的目的 MAC 地址是 PC2 的 MAC 地址，当数据到达 R1 时，R1 检查目的 MAC 地址后发现并不是发往本路由器的，它会直接丢弃这个数据。

PC1 在物理层将数据帧转换成比特流发往交换机 SW1，SW1 在 CAM 表中查找数据帧的目的 MAC 地址。如果查找到对应的条目，就将该数据帧交由相应的端口转发。否则就向除了源端口外的所有端口泛洪该数据帧。
![SW1](https://raw.githubusercontent.com/orionleo/Markdown-Photos/master/SW1.png)

R1 收到 SW1 转发的数据帧后发现其中的目的 MAC 地址正是本路由器 Gig0/1 接口的 MAC 地址，随后拆掉 Ethernet 首部将剩下的部分传递至网络层。在网络层检查数据包中的目的 IP 地址，发现并不是发给本路由器的，因此需要进行转发。R1 查找路由表中是否有包含了目的 IP 地址的路由条目，如果有就从对应的出站接口转发至下一跳路由器，否则直接丢弃该数据包。数据帧在被解封装成数据包传递至网络层后，还需要进行再封装才能从物理层发出。不同于主机和二层交换机运行在局域网链路上，路由器通常运行在广域网链路上，而 PPP 协议正是广域网链路上被广泛使用的一种数据链路层协议，它能把上层数据封装成 PPP 数据帧通过点对点链路发往对端，PPP 数据帧格式如下图：
![R1 -> R2](https://raw.githubusercontent.com/orionleo/Markdown-Photos/master/R1%20-%20R2.png)

R2 在收到 R1 转发的数据帧后，拆掉 PPP 首部传递至网络层处理。在网络层检查数据包中的目的 IP 地址，发现并不是发给本路由器的，但 R2 查找路由表后发现目的 IP 地址属于自己的直连网段，可以通过对应的出站接口转发数据包。因此 R2 需要在 ARP 缓存中查找 PC2 的 MAC 地址，如果查找到对应的条目就利用该 MAC 地址封装数据包，否则先发送 ARP 请求，收到响应后再封装，并将封装完成的数据帧从 Gig0/1 发出。
![R2 -> PC2](https://raw.githubusercontent.com/orionleo/Markdown-Photos/master/R2%20-%20PC2.png)

R2 发出的数据帧到达 SW2 后，SW2 在 CAM 表中查找数据帧中目的 MAC 地址所对应的端口，并由该端口将数据发往 PC2。如果没有对应的条目，就向除了源端口外的所有端口泛洪该数据帧。
![SW2](https://raw.githubusercontent.com/orionleo/Markdown-Photos/master/SW2.png)

PC2 在收到数据帧后，会将数据帧向上传递至数据链路层并拆掉 PPP 首部，检查目的 MAC 地址是否为本机。如果是，向上传递至网络层并拆掉 IP 首部，检查目的 IP 地址是否为本机。如果是，向上传递至传输层并拆掉 TCP 首部，检查目的端口号是否为 23。如果是，将数据交由应用层处理。

## 总结
到此为止，数据的旅行就结束了。从整个流程上来看，数据在不同的网络设备上执行的无外乎都是 OSI 模型中下三层的操作。从头到尾未发生改变的是数据包中的源、目的 IP 地址，而在数据链路层源、目的 MAC 地址会随着转发的进行作出对应的修改。
