# TCP Congestion Control

## 引言
网络中的路由器遇到大量突然涌入的数据无法即时处理，而被迫丢弃部分数据的现象称之为网络拥塞。这是发送端和接收端承担了超过其负荷的通信任务，通常可以考虑采用降低发送端的发送速率或者丢弃部分数据的方法，也可将两种方法结合使用。

如前文所述，针对丢包的情况，TCP 采取的首要机制是重传，包括超时重传和快速重传。设想以下场景，当网络已经处于拥塞崩溃状态时，共用同一条传输路径的多个 TCP 连接（此处的 TCP 连接是指由发送端 IP 地址，发送端 Port 号，接收端 IP 地址和接收端 Port 号构成的四元组，其中任意一端的 IP 地址和 Port 号构成一个 Socket）却需要重传多个数据段来保证对端数据的正确性，这好比火上浇油，无疑只会让当前的网络状态更糟糕，所以应当尽可能避免重传的发生或者减少重传的次数。因此，在 TCP 断定当前网络中已经出现丢包的情况后，会立刻减缓发送端的发送速率。若网络拥塞情况有所缓解，就重新检测新的可用带宽。

本文首先介绍 TCP 在建立新连接的过程中如何寻找并确立最佳传输速率，接下来介绍 TCP 何时减速以及怎样减速，包括如何快速恢复传输速度。

## 定义
1. **_SMSS_**（Sender Maximum Segment Size）：发送端能够发送的最大数据段的大小，该数据段的大小不包括 IP Header，TCP Header 和 TCP Option。 

2. **_RMSS_**（Receiver Maximum Segment Size）：接收端能够接收的最大数据段的大小，RMSS 是在三次握手的过程中由接收端在 MSS Option 中指定。同样，该数据段的大小不包括 IP Header，TCP Header 和 TCP Option。

3. **_RWND_**（Receiver Window）：最近通告的接收端窗口。

4. **_CWND_**（Congestion Window）：TCP 状态变量，用于限制发送端可以发送的数据量。发送端实际可用窗口 _W_ 就是拥塞窗口和通告的接收端窗口的较小者。
_W = min(CWND, AWND)_
在任何一段时间内，发送端都不得发送 SEQ 大于 ACK 最大值和 _W_ 之和的数据段。
_SEQ < ACK(lastest) + W_

5. **_IW_**（Initial Window）：三次握手完成后发送端拥塞窗口的大小。

6. **_LW_**（Loss Window）：利用重传计时器检测到丢包后发送端拥塞窗口的大小。

7. **_RW_**（Restart Window）：重新开始传输后发送端拥塞窗口的大小。

8. **_Flight Data_**：发送端已经发送出但还未被累积确认的数据，也称“在途数据”。

9. **_SSThresh_**：另一个 TCP 状态变量，用于确定使用慢启动算法还是拥塞避免算法来控制数据传输。

## 慢启动
**_当一个新的 TCP 连接建立或检测到由重传超时（RTO）导致的丢包时，需要执行慢启动。_**

在传输的初始阶段，由于无法准确得知当前网络的传输能力，要求 TCP 发送端缓慢探测网络以确定可用带宽，避免在短时间内注入大量的数据导致网络拥塞。慢启动算法正是针对这一问题而设计，因此在数据传输伊始或者重传计时器检测到丢包发生时，都需要执行慢启动算法。

当完成 TCP 三次握手后，发送端通过发送一定数量的数据段进入慢启动阶段，这里将所发送的数据段称之为初始窗口（Initial Window）。通常情况将 IW 的初始值设为一个 SMSS，但是在 RFC 5681 的描述中却略有不同，其根据不同的 SMSS 大小设置初始值。

```java
if (SMSS > 2190 bytes)
    IW = 2 * SMSS;
if (SMSS > 1095 bytes && SMSS <= 2190 bytes)
    IW = 3 * SMSS;
if (SMSS <= 1095 bytes)
    IW = 4 * SMSS;
```

为了描述方便，接下来只讨论 IW = 1 * SMSS 这一种情况。假设当前网络中还未没有出现丢包的情况且每个数据段都有与之对应的 ACK（先不考虑延迟 ACK）。**_在老版本的 TCP 实现中，发送端收到的每个用于累计确认新数据的 ACK 都可以增大 CWND 最多 SMSS 个字节。_** 为了能将这一句话理解透彻，需要引申一段 TCP 滑动窗口的知识。

> 建立 TCP 连接的每一端都可以收发数据，而连接两端负责数据收发的重任则是由一组窗口结构来维护的，即发送端和接收端各自维护着一个发送窗口结构（Send Window）和接收窗口结构（Receive Window）。

> TCP 以字节而非数据段为单位维护其窗口结构。在发送窗口结构中记录了“已发送并已确认”、“已发送但未经确认”和“即将发送”三组数据的序列号。接收窗口结构则相对简单一些，其记录了“已接收并确认”、“已接收将会保存”两组数据的序列号。

已发送并已确认 | 已发送但未经确认 | 即将发送
:-----------: | :-----------: | :-----------:
... 2 3 | 4 5 6 | 7 8 9 

已接收并确认 | 已接收将会保存
:-----------: | :-----------: |
... 2 3 | 4 5 6 7 8 9

了解了这两种窗口结构之后再来理解上面那句话，其中的“用于累计确认新数据的 ACK”指的是即将用来确认发送窗口中“已发送但未经确认”的数据的 ACK，称之为“常规 ACK”而非所有形式 ACK。**_在新版本的 TCP 实现中，在慢启动阶段会以 min(N, SMSS) 来增加 CWND 的值, 公式中的 N 代表了经由常规 ACK 确认的先前未经确认的字节数。_** 这样不仅可以支持适当节计数（ABC）计数，而且提高了应对行为不当的接收端的鲁棒性，这些接收端可能尝试使用称为“ACK 分区”的机制诱导发送端人为地膨胀 CWND 的大小。

因此，在接收到一个数据段的 ACK 后，发送端就会将当 CWND 的值增加到 2，接着会发送两个新的数据段，如果成功接收到了相应的 ACK，CWND 的值就会由 2 变成 4，由 4 变成 8，以此类推。这种指数级的增长看似很快，但跟一开始就允许以最大可用速率发送相比就相形见绌了。

<div align=center><img width="273" height="354" src="https://raw.githubusercontent.com/orionleo/Markdown-Photos/master/%E7%BB%8F%E5%85%B8%E6%85%A2%E5%90%AF%E5%8A%A8%E7%AE%97%E6%B3%95%E6%93%8D%E4%BD%9C.jpg"/></div>

正如前文所述，CWND 的值会随着 RTT 呈指数级增长，这就带来了慢启动后期大量数据段的发送致使网络的瘫痪。需要帮助 TCP 确立一个慢启动阈值 SSThresh，一旦达到阈值，就意味着可能有更多可用的传输资源。但如果立即占用这部分资源，将会使网络中的路由器及其他设备出现严重的丢包和重传情况，从而导致整个网络性能不稳定。

SSThresh 和 SWND 的关系是决定采用慢启动还是拥塞避免的分界线。当 CWND < SSThresh 时，使用慢启动算法；当 CWND >= SSThresh 时，使用拥塞避免算法。**_慢启动阈值并不是一个固定的值，而是会随着探测进程改变的。在网络没有出现丢包的情况下，记录了 TCP 最优窗口估计值的下限。_**

由于篇幅有限（主要是打字打得手太酸了0.0），拥塞避免和重传部分会在下面详细展开，有不对的地方还望大家指出，谢谢！
